---
title: 你需要更优雅的 Dialog/Modal 使用姿势！
date: 2023-03-22 19:21:28
permalink: /pages/1b3356/
categories:
  - JavaScript
tags:
  - 
---

你好，我是泰罗凹凸曼，弹窗组件是我们平时开发中使用的最多的组件之一，那么如何更优雅的使用弹窗组件，怎么样封装弹窗组件才更利于业务，怎么样让代码结构变得更清晰，已经是一个势在必行的问题了。

想得多不如做的多，做得多不如看得多，我的思路不代表最优秀的设计，仅是我日常工作中的一些缩影，希望可以帮助到你！

## 常见的弹窗

鉴于Vue的状态驱动的模型，我们的大部分弹窗都是状态驱动的，这是很完美的，也是很舒服的一种使用方式，但是我们很容易就会写出类似于下面的代码：

```html
<template>
  <button @click="openDialog"></button>
  
  <some-dialog v-model:visible="showDialog" @success="handleSuccess" @close="closeDialog" />
</template>

<script setup>
const showDialog = ref(false)

function openDialog() {
    showDialog.value = true
}

function handleSuccess(value) {
  something.value = value
  showDialog.value = false
}

function closeDialog() {
    showDialog.value = false
}
</script>
```

这种写法是没问题的，但是这只是最简单的一种使用方式，基于上面的状态驱动的方式，我们很容易就可以写出很糟糕的代码，看看吧：
```html
<template>
  <button @click="openDialogA"></button>
  <button @click="openDialogB"></button>
  <button @click="openDialogC"></button>
  <button @click="openDialogD"></button>
  <button @click="openDialogE"></button>
  
  <some-dialog-a v-model:visible="showDialogA" @success="handleSuccessA" @close="closeDialogA" />
  <some-dialog-b v-model:visible="showDialogB" @success="handleSuccessB" @close="closeDialogB" />
  <some-dialog-c v-model:visible="showDialogC" @success="handleSuccessC" @close="closeDialogC" />
  <some-dialog-d v-model:visible="showDialogD" @success="handleSuccessD" @close="closeDialogD" />
  <some-dialog-e v-model:visible="showDialogE" @success="handleSuccessE" @close="closeDialogE" />
</template>

<script setup>
const showDialogA = ref(false)

function openDialogA() {...}
function handleSuccessA(value) {...}
function closeDialogA() {...}

const showDialogB = ref(false)

function openDialogB() {...}
function handleSuccessB(value) {...}
function closeDialogB() {...}
  
// ...
</script>
```

这样的代码，我们很容易就会发现，我们的代码逻辑就变得异常的复杂，这样的代码，如果有人要维护，那么就会变得异常的痛苦，因为代码的耦合度太高了，代码的可维护性就变得异常的差。

## 业务耦合

我们再看看，如果我们的业务逻辑变得更复杂的话，我们的代码会变成什么样子呢？

```html
<template>
  <button @click="openDialog"></button>
  
  <some-dialog v-model:visible="showDialog" :isEdit="isEdit" :isCreate="isCreate" :isDetail="isDetail" @success="handleSuccess" @close="closeDialog" />
</template>

<script setup>
const showDialog = ref(false)
const isEdit = ref(false)
const isCreate = ref(false)
const isDetail = ref(false)

function openDialog() {
  showDialog.value = true
  isEdit.value = true
  isCreate.value = false
  isDetail.value = false
}

function handleSuccess(value) {
  something.value = value
  showDialog.value = false
}

function closeDialog() {
  showDialog.value = false
  isEdit.value = false
  isCreate.value = false
  isDetail.value = false
}
</script>
```

相信诸位应该很容易在公司的业务代码中看到如上的代码片段，一个部分的改动有可能牵扯到全局的改动，大家可以想一想，如果，我又需要在弹窗中加一个编辑功能 `isEdit`，我需要修改的内容到底有多少。

如果再夹杂一下其他的业务逻辑的话，那么这些弹窗的事件和状态将让整个逻辑变得异常臃肿！

所以我们就从组件使用者的角度出发，看看如何才能更优雅的去封装组件，我们今天的目标是：消除逻辑耦合，组件业务自驱！

## 从需求出发

"能力在修炼在产出结果之后，思维的修炼在产出结果之前"，我们先准备一个简单的小需求，一步步带大家了解业务的复杂度是如何一步一步提高的。

我们先来看看，我们的需求是什么样子的？

- 准备一个学生名单，存在三个按钮，编辑，详情，删除
- 再准备一个新增学生的按钮
- 点击新增按钮。弹出新增学生的弹窗
- 点击编辑按钮，弹出新增学生的弹窗，不过当前的状态是编辑状态
- 点击详情按钮，弹出学生信息的弹出，就是新增弹窗的复用，内部的字段 disabled 或者是将表单字段替换为纯文本字段
- 点击删除按钮，弹出删除确认的弹窗，需要输入删除原因

相信大家做这个需求还是游刃有余的，但是随着需求的越来越多，我们来看看具体会变成什么样子！

特意为大家准备了小需求的实现代码：[戳这里](https://github.com/TaroXin/better-dialog-example)

我们先看最基本的一个版本，也是状态驱动最常见的一个版本！我删除了一些不必要的代码，只保留了核心的代码，完整的代码可以[戳这里](https://github.com/TaroXin/better-dialog-example/blob/main/src/views/normal/index.vue)

```html
<script setup lang="ts">
  const studentList = ref<Student[]>(mockStudent)

  const showDetail = ref(false)
  const isForDetail = ref(false)
  const editStudent = ref<Student>()

  const toEdit = (stu?: Student, isDetail = false) => {
    showDetail.value = true
    editStudent.value = stu
    isForDetail.value = isDetail
  }

  const handleStudentSave = (stu: Student) => {
    // 如果 editStudent 中的 id 不为空，则为编辑，否则为新增
    if (stu.id != null) {
      const existIndex = studentList.value.findIndex(es => es.id === stu.id)
      if (existIndex >= 0) {
        studentList.value[existIndex] = {
          ...stu,
        }
      }
    }
    else {
      studentList.value.push({
        ...stu,
        id: studentList.value.length,
      })
    }
  }
</script>

<template>
  <div class="student-list">
    <el-button type="primary" @click="toEdit()">
      新增学生
    </el-button>
    <div class="list-wrap">
      <div v-for="stu in studentList" :key="stu.id" class="list-item">
        <div>{{ stu.name }}</div>
        <div>{{ stu.age }}</div>
        <div>{{ stu.gender === 'F' ? '女' : '男' }}</div>
        <div>
          <el-button type="primary" size="small" @click="toEdit(stu)">
            编辑
          </el-button>
          <el-button type="info" size="small" @click="toEdit(stu, true)">
            详情
          </el-button>
          <el-button type="danger" size="small">
            删除
          </el-button>
        </div>
      </div>
    </div>
    <StudentDetail v-model="showDetail" :edit-student="editStudent" :is-for-detail="isForDetail" @save="handleStudentSave" />
  </div>
</template> 
```

**这是这个需求最最最基础的版本，我们还没有添加众多的迭代，那么一个详情弹窗对我们代码的侵入性有多强？**

- 我们添加了 `showDetail` 控制弹窗的显隐
- 我们添加了 `toEdit` 来实现打开弹窗，控制其是新增，编辑或者详情
- 我们添加了 `handleStudentSave` 方法来处理弹窗中的返回值
- 我们还添加了 `isForDetail` 来控制是不是显示详情而非编辑
- ...

这一系列的状态变更，仅仅是我们需要一个学生的编辑弹窗，如果，我需要该页面再添加一个新增班级的弹窗呢？再添加一个新增老师的弹窗呢？复杂的业务级需求在实际工作中并不少见！

到如此，我们还没有实现删除功能，也就是说，我的状态又要多加一层！

可预见的是，当需求越来越复杂的时候，不可避免的我们的代码中会出现各种各样的状态声明，如 `showXXX`、`handleXXX`、`toXXX`、`isXXX`，难道没办法了吗？当然有的！

## useDialog

我们知道，在Vue3里面，可以使用 Composition API 来完成组件逻辑的封装，使用方式也类似于 React hooks，所以一般来说，我一般喜欢称之为 Vue hooks，如何使用 hooks 来封装弹窗逻辑？

简单来讲，我们学生弹窗的业务属于学生弹窗的部分，不属于列表的业务需求，那这么多和列表页面耦合的状态我们能忍吗，当然不能忍！

hooks 在拆分业务逻辑上是有非常好的优势的，我们来看看如果使用了 hooks 的话，我们的代码会变成什么样子！

我们将业务逻辑一股脑的交给 `useStudentDetail` 去处理：
```html
<script setup lang="ts">
  const {
    showDetail,
    isForDetail,
    editStudent,
    toEdit,
    handleStudentSave,
  } = useStudentDetail(studentList)
</script>

<template>
  <StudentDetail
    v-model="showDetail"
    :edit-student="editStudent"
    :is-for-detail="isForDetail"
    @save="handleStudentSave"
  />
</template>
```

## ElementUI 是如何实现的

## 如何实现业务自驱

## 命令驱动 or 状态驱动 ？
