---
title: 用 JavaScript 写出一个彩票系统？
date: 2023-02-15 23:43:45
permalink: /pages/7def50/
categories:
  - JavaScript
tags:
  - JavaScript
  - 杂谈
---

原本这篇文章是打算叫「假如我是彩票系统开发者」，但细想一下，如果在文章中引用太多的 JavaScript 的话，反而不是那么纯粹，毕竟也只是我的一厢情愿，彩票开发也不全如本文所讲，有所误导的话便也是得不偿失了。

所以索性就叫「用 JavaScript 写出一个彩票系统」，也算明朗了一些，声明一下，**真实的彩票系统不是这么开发出来的，也不具备明面上的规律，我们应该相信彩票的公正性**，尽管其可能不是基于随机！

## 杂谈 

最近大抵是迷上彩票了，幻想着自己若能暴富，也可以带着家庭"鸡犬升天"了，不过事与愿违，我并没有冲天的气运，踏踏实实工作才是出路？

买彩票的时候，我也考虑了很久，到底怎么样的号码可以在1700万注中脱颖而出，随机试过，精心挑选的也试过，找规律的模式也试过，甚至我还用到了爬虫去统计数据，啼笑人非！

我们默认彩票系统是基于统计学来实现一等奖的开奖，那么历史以来的一等奖理所当然应该是当期统计率最低的一注，所以，最开始的时候我是这么想的：

1. 获取历史以来所有的中奖彩票号码
2. 使用代码去统计出所有号码的中奖次数
3. 按照出现几率最低的数字来排序
4. 依次组成某几注新号码

天马行空，却也是自己发财欲望的一种发泄渠道罢了，称之为异想天开也不为过，扯了挺多，哈哈！

上面的思路我已经实践过了，用了差不多一年的时间，没有用！别用！当然你也可以试试，如果你中了，恭喜，你才是天选之人！


## 彩票的规则

我们这里的彩票规则统一使用「双色球」的规则来说明，其购买的规则如下：

1. 红球为六位，选项从 1 - 33 中挑选，不可重复
2. 蓝球为一位，选项从 1 - 16 中挑选
3. 红蓝双色球一共七位组成一注

一等奖一般中全部购买的注里面挑选一注，这一注可能被多个人买，也有可能是一个人买了该注的倍数。

所以粗略统计，彩票的中奖几率计算公式如下所示：

使用组合数公式来计算，从`n`个元素中取`k`个元素的的组合数公式为：

$$C\binom{k}{n}=\frac{n!}{k!(n-k)!}$$

根据公式，我们可以很容易的写出来一个简单的算法：
```javascript
function factorial(n) {
  if (n === 0 || n === 1) {
    return 1
  } else {
    return n * factorial(n - 1)
  }
}

function combination(n, k) {
  return factorial(n) / (factorial(k) * factorial(n - k))
}

console.log(combination(33, 6) * combination(16, 1)) // 17721088
```

所以可以得出的结论是，双色球头奖的中奖几率为：
$$\frac{1}{17721088}$$

## 数据量

我们通过上面的算法得知了彩票的总注数为 `17721088`，那么这么多注数字组成的数据到底有多大呢？

简单计算下，一注彩票可以用14个数字来表示，如 `01020304050607`，那么在操作系统中，这串数字的大小为 `14B`，那么粗略可知的是，如果所有的彩票注数都在一个文件中，那么这个文件的大小为：

```javascript
const totalSize = 17721088 * 14 / 1024 / 1024 // 236.60205078125MB
```

很恐怖的数量，有没有可能更小？我们研究一下压缩算法！

`01`这个数字在内存中的占用是两个字节，也就是 2B，那如果我们把 `01` 用小写 `a` 代替，那么其容量就可以变成 1B，总体容量可减少一半左右！

![](http://rq07mqsm6.hn-bkt.clouddn.com/u-image-bed/1678716702848.png)

这样子的话，我们上面的一注特别牛的号码 `01020304050607` 就可以表示为 `abcdefg` !

这就是压缩算法最最最基本的原理，压缩算法有很多种，大体分为有损压缩和无损压缩，对于我们数据类的内容来讲，我们一般都会选择无损压缩！

- 有损压缩算法：这些算法能够在压缩数据时丢弃一些信息，但通常能在不影响实际使用的前提下实现更高的压缩比率，其中最常见的是图像、音频和视频压缩算法
- 无损压缩算法：这些算法不会丢弃任何信息，它们通过查找输入数据中的重复模式，并使用更短的符号来表示它们来实现压缩。无损压缩算法常用于文本、代码、配置文件等类型的数据

首先，让我们先准备一些测试数据，我们使用下面这个简单的组合数生成算法来获取出1000个组合数：
```javascript
function generateCombinations(arr, len, maxCount) {
  let result = []
  
  function generate(current, start) {
    // 如果已经生成的组合数量达到了最大数量，则停止生成
    if (result.length === maxCount) {
      return
    }

    // 如果当前已经生成的组合长度等于指定长度，则表示已经生成了一种组合
    if (current.length === len) {
      result.push(current)
      return
    }

    for (let i = start; i < arr.length; i++) {
      current.push(arr[i])
      generate([...current], i + 1)
      current.pop()
    }
  }

  generate([], 0)
  return result
}
```

接下来，我们需要生成 1000 注双色球，红球是从 1 - 33 中取组合数，蓝球是从 1 - 16 中依次取数

```javascript
function getDoubleColorBall(count) {
  // 红球数组：['01', '02' .... '33']
  const arrRed = Array.from({ length: 33 }, (_, index) => (index + 1).toString().padStart(2, '0'))
  const arrRedResult = generateCombinations(arrRed, 6, count)

  const result = []
  let blue = 1
  arrRedResult.forEach(line => {
    result.push(line.join('') + (blue++).toString().padStart(2, '0'))
    if (blue > 16) {
      blue = 1
    }
  })

  return result
}
```

我们将获取的彩票内容放在文件中以便于下一步操作：

```javascript
const firstPrize = getDoubleColorBall(1000).join('')
fs.writeFileSync('./hello.txt', firstPrize)
```

这样子，我们就得到了第一版的文件，这是其文件大小：

![](http://rq07mqsm6.hn-bkt.clouddn.com/u-image-bed/1678723639832.png)

试一下我们初步的压缩算法，我们将刚刚设定好的规则，也就是数字到字母的替换，用 JavaScript 实现出来，如下：

```javascript
function compressHello() {
  const letters = 'abcdefghijklmnopqrstuvwxyzABCDEFG'
  const doubleColorBallStr = getDoubleColorBall(1000).join('')
  let resultStr = ''
  for (let i = 0; i < doubleColorBallStr.length; i+=2) {
    const number = doubleColorBallStr[i] + doubleColorBallStr[i+1]
    resultStr += letters[parseInt(number) - 1]
  }
  return resultStr
}

const firstPrize = compressHello()
fs.writeFileSync('./hello-1.txt', firstPrize)
```

这样我们就得到了一个全新的 hello 文件，他的大小如下所示，正好印证了我们的想法！

![](http://rq07mqsm6.hn-bkt.clouddn.com/u-image-bed/1678723704026.png)

如果按照这个算法的方法，我们能将之前的文件压缩至一半大小，也就是 `118.301025390625MB`，但是这就是极限了吗？不，上面我们讲过，这只是最基本的压缩，接下来，让我们试试更精妙的方法！

## 更精妙的方法

这里我们不对压缩算法的原理做过多的解释，如果诸位感兴趣的话，可以自己寻找类似的文章阅读，鉴于网上的文章质量参差不齐，我就不做推荐了！

这里我们需要了解的是，我们正在研究的是一个彩票系统，所以他的数据压缩应该具备以下几个特征：

- 具备数据不丢失的特性，也就是无损压缩
- 压缩率尽可能小，因为传输的文件可能非常大，如我们上面举的例子
- 便于信息的传输，也就是支持HTTP请求

常做前端的同学应该知道，我们在 HTTP 请求头里面常见的一个参数 `content-encoding: gzip`，在项目的优化方面，也会选择将资源文件转换为 `gzip` 来进行分发。在日常的使用中，我们也时常依赖 `Webpack`，`Rollup` 等库，或者通过网络服务器如 `nginx` 来完成资源压缩，`gzip` 不仅可以使得发送的内容大大减少，而且客户端可以无损解压访问源文件。

那么，我们能不能使用 `gzip` 来完成压缩呢？答案是可以，`Node.js` 为我们提供了 `zlib` 工具库，提供了相应的压缩函数：
```javascript
const zlib = require('zlib')

const firstPrize = compressHello()
fs.writeFileSync('./hello-2.txt.gz', zlib.gzipSync(firstPrize))
```

得到的结果是：
![](http://rq07mqsm6.hn-bkt.clouddn.com/u-image-bed/1678807704942.png)

我们完成了 14KB -> 3KB 的压缩过程！是不是很有意思？不过还是那句话，有没有可能更小？当然可以！

`content-encoding` 响应头一般是服务器针对返回的资源响应编码格式的设置信息，常见的值有以下三种：

- `gzip` 所有浏览器都支持的通用压缩格式
- `brotli` 比 `gzip` 压缩性能更好，压缩率更小的一个新的压缩格式，老版本浏览器不支持
- `deflate` 出于某些原因，使用不是很广泛，后有基于该算法的 `zlib` 压缩格式，不过也使用度不高

浏览器支持的压缩格式不只是这些，不过我们列举出的是较为常用的，我们尝试使用一下这三种压缩格式：

```javascript
const firstPrize = compressHello()
fs.writeFileSync('./hello-2.txt.gz', zlib.gzipSync(firstPrize))
fs.writeFileSync('./hello-2.txt.def', zlib.deflateSync(firstPrize))
fs.writeFileSync('./hello-2.txt.br', zlib.brotliCompressSync(firstPrize))
```

我们可以看到，`deflate` 和 `gzip` 的压缩率不相上下，令人惊喜的是，`brotli`的压缩竟然达到了惊人的 1KB ! 这不就是我们想要的吗？

![](http://rq07mqsm6.hn-bkt.clouddn.com/u-image-bed/1678812002467.png)

还可能更小吗？哈哈哈哈，当然，如果不考虑HTTP支持，我们完全可以使用如 `7-zip` 等压缩率更低的压缩算法去完成压缩，然后使用客户端做手动解压。不过点到为止，更重要的工作我们还没有做！

在这之前，我们需要先了解一下解压过程，如果解压后反而数据丢失，那就得不偿失了！

```javascript
// 执行解压操作
const brFile = fs.readFileSync('./hello-2.txt.br')
const gzipFile = fs.readFileSync('./hello-2.txt.gz')
const deflateFile = fs.readFileSync('./hello-2.txt.def')

const brFileStr = zlib.brotliDecompressSync(brFile).toString()
const gzipFileStr = zlib.gunzipSync(gzipFile).toString()
const deflateFileStr = zlib.inflateSync(deflateFile).toString()

console.log(brFileStr)
console.log(gzipFileStr)
console.log(deflateFileStr)

console.log(brFileStr === gzipFileStr, brFileStr === deflateFileStr) // true, true
```

如上，我们知晓尽管压缩算法的效果很惊人，但是其解压后的数据依然是无损的！

## 完整的数据

让我们构建出完整的 17721088 注数据测试一下完整的压缩算法的能力如何？这里我们使用 `brotli` 和 `gzip` 算法分别进行压缩测试！

首先，应该修改我们生成数据的函数，如下：

```javascript
function generateAll() {
  const arrRed = Array.from({ length: 33 }, (_, index) => (index + 1).toString().padStart(2, '0'))
  const arrRedResult = generateCombinations(arrRed, 6, Number.MAX_VALUE)

  const result = []
  arrRedResult.forEach(line => {
    for (let i = 1; i <= 16; i++) {
      result.push(line.join('') + i.toString().padStart(2, '0'))
    }
  })

  return result
}

console.log(generateAll().length) // 17721088
```

接下来我们要经过初步压缩并将其写入文件中：

```javascript
function compressAll() {
  const letters = 'abcdefghijklmnopqrstuvwxyzABCDEFG'
  const allStr = generateAll().join('')
  let resultStr = ''
  for (let i = 0; i < allStr.length; i += 2) {
    const number = allStr[i] + allStr[i+1]
    resultStr += letters[parseInt(number) - 1]
  }
  return resultStr
}

const firstPrize = compressAll()
fs.writeFileSync('./all-ball.txt', firstPrize)
```

![](http://rq07mqsm6.hn-bkt.clouddn.com/u-image-bed/1678813717783.png)

正如我们预料的，经过初步压缩之后，文件大小达到了大约 118MB，但是其实际占用 124MB，是属于计算机存储的范畴，我们现在不在本篇文章中讨论，感兴趣的同学可以自己查一查，根据字节数计算，其大小为：

```javascript
const totalSize = 124047616 / 1024 / 1024 // 118.30102539 MB
```

目前来看是符合预期的，我们来看看两个压缩算法的真本事！

```javascript
const firstPrize = compressAll()
fs.writeFileSync('./all-ball.txt.gz', zlib.gzipSync(firstPrize))
fs.writeFileSync('./all-ball.txt.br', zlib.brotliCompressSync(firstPrize))
```

![](http://rq07mqsm6.hn-bkt.clouddn.com/u-image-bed/1678814436883.png)

其实是很震惊的一件事情，尽管我对 `brotli` 的期待足够高，也不会想到他能压缩到仅仅 4M 大小，不过对于我们来说，这是一件幸事，对于之后的分发操作有巨大的优势！

## 随机来两注

从彩票站购买彩票的时候，随机来两注的行为是非常常见的，但是当你尝试随机号码的时候，会发生什么呢？

我们先从彩票数据的分发讲起，首先彩票数据的分发安全性和稳定性的设计肯定是毋庸置疑的，但是这不是我们目前需要考虑的问题，目前我们应该解决的是，如果才能更低程度的控制成本！

假设设计这套系统的人是你，如果控制随机号码的中奖率？我的答案是，从已有的号码池里面进行选择！

如果让每个彩票站获取到其对应的号码池，答：数据分发！如果采用数据分发的模式的话，需要考虑的问题如下：

- 什么时候进行分发
- 这些数据交给彩票站的策略
- 数据回源如何做
- 如何避免所有数据被劫持

据2021年公开信息，彩票站的数量已经达到20万家（未查证，无参考价值），我们假设目前的彩票站数量为 30 万家！

### 什么时候进行分发

我们知道的是，彩票的购买截止时间是在晚上八点，开奖时间是在晚上的九点十五，在晚上八点之后，我们只能购买到下一期的彩票，那么这个节点应该从晚上的八点开始，计划是这样子的：

1. 从目前已有的彩票库里面，按照号码出现几率从高到低排列
2. 挑选出50万注

## 特意挑的两注

## 我要一等奖

## 黄粱一梦

## 结语
