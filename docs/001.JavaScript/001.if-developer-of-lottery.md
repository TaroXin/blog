---
title: 用 JavaScript 写出一个彩票系统？
date: 2023-02-15 23:43:45
permalink: /pages/7def50/
categories:
  - JavaScript
tags:
  - JavaScript
  - 杂谈
---

原本这篇文章是打算叫「假如我是彩票系统开发者」，但细想一下，如果在文章中引用太多的 JavaScript 的话，反而不是那么纯粹，毕竟也只是我的一厢情愿，彩票开发也不全如本文所讲，有所误导的话便也是得不偿失了。

所以索性就叫「用 JavaScript 写出一个彩票系统」，也算明朗了一些，声明一下，**真实的彩票系统不是这么开发出来的，也不具备明面上的规律，我们应该相信彩票的公正性**，尽管其可能不是基于随机！

## 杂谈 

最近大抵是迷上彩票了，幻想着自己若能暴富，也可以带着家庭"鸡犬升天"了，不过事与愿违，我并没有冲天的气运，踏踏实实工作才是出路？

买彩票的时候，我也考虑了很久，到底怎么样的号码可以在1700万注中脱颖而出，随机试过，精心挑选的也试过，找规律的模式也试过，甚至我还用到了爬虫去统计数据，啼笑人非！

我们默认彩票系统是基于统计学来实现一等奖的开奖，那么历史以来的一等奖理所当然应该是当期统计率最低的一注，所以，最开始的时候我是这么想的：

1. 获取历史以来所有的中奖彩票号码
2. 使用代码去统计出所有号码的中奖次数
3. 按照出现几率最低的数字来排序
4. 依次组成某几注新号码

天马行空，却也是自己发财欲望的一种发泄渠道罢了，称之为异想天开也不为过，扯了挺多，哈哈！

上面的思路我已经实践过了，用了差不多一年的时间，没有用！别用！当然你也可以试试，如果你中了，恭喜，你才是天选之人！


## 彩票的规则

我们这里的彩票规则统一使用「双色球」的规则来说明，其购买的规则如下：

1. 红球为六位，选项从 1 - 33 中挑选，不可重复
2. 蓝球为一位，选项从 1 - 16 中挑选
3. 红蓝双色球一共七位组成一注

一等奖一般中全部购买的注里面挑选一注，这一注可能被多个人买，也有可能是一个人买了该注的倍数。

所以粗略统计，彩票的中奖几率计算公式如下所示：

使用组合数公式来计算，从`n`个元素中取`k`个元素的的组合数公式为：

$$C\binom{k}{n}=\frac{n!}{k!(n-k)!}$$

根据公式，我们可以很容易的写出来一个简单的算法：
```javascript
function factorial(n) {
  if (n === 0 || n === 1) {
    return 1
  } else {
    return n * factorial(n - 1)
  }
}

function combination(n, k) {
  return factorial(n) / (factorial(k) * factorial(n - k))
}

console.log(combination(33, 6) * combination(16, 1)) // 17721088
```

所以可以得出的结论是，双色球头奖的中奖几率为：
$$\frac{1}{17721088}$$

## 数据量

我们通过上面的算法得知了彩票的总注数为 `17721088`，那么这么多注数字组成的数据到底有多大呢？

简单计算下，一注彩票可以用14个数字来表示，如 `01020304050607`，那么在操作系统中，这串数字的大小为 `14B`，那么粗略可知的是，如果所有的彩票注数都在一个文件中，那么这个文件的大小为：

```javascript
const totalSize = 17721088 * 14 / 1024 / 1024 // 236.60205078125MB
```

很恐怖的数量，有没有可能更小？我们研究一下压缩算法！

`01`这个数字在内存中的占用是两个字节，也就是 2B，那如果我们把 `01` 用小写 `a` 代替，那么其容量就可以变成 1B，总体容量可减少一半左右！

![](http://rq07mqsm6.hn-bkt.clouddn.com/u-image-bed/1678716702848.png)

这样子的话，我们上面的一注特别牛的号码 `01020304050607` 就可以表示为 `abcdefg` !

这就是压缩算法最最最基本的原理，压缩算法有很多种，大体分为有损压缩和无损压缩，对于我们数据类的内容来讲，我们一般都会选择无损压缩！

- 有损压缩算法：这些算法能够在压缩数据时丢弃一些信息，但通常能在不影响实际使用的前提下实现更高的压缩比率，其中最常见的是图像、音频和视频压缩算法
- 无损压缩算法：这些算法不会丢弃任何信息，它们通过查找输入数据中的重复模式，并使用更短的符号来表示它们来实现压缩。无损压缩算法常用于文本、代码、配置文件等类型的数据

首先，让我们先准备一些测试数据，我们使用下面这个简单的组合数生成算法来获取出1000个组合数：
```javascript
function generateCombinations(arr, len, maxCount) {
  let result = []
  
  function generate(current, start) {
    // 如果已经生成的组合数量达到了最大数量，则停止生成
    if (result.length === maxCount) {
      return
    }

    // 如果当前已经生成的组合长度等于指定长度，则表示已经生成了一种组合
    if (current.length === len) {
      result.push(current)
      return
    }

    for (let i = start; i < arr.length; i++) {
      current.push(arr[i])
      generate([...current], i + 1)
      current.pop()
    }
  }

  generate([], 0)
  return result
}
```

接下来，我们需要生成 1000 注双色球，红球是从 1 - 33 中取组合数，蓝球是从 1 - 16 中依次取数

```javascript
function getDoubleColorBall(count) {
  // 红球数组：['01', '02' .... '33']
  const arrRed = Array.from({ length: 33 }, (_, index) => (index + 1).toString().padStart(2, '0'))
  const arrRedResult = generateCombinations(arrRed, 6, count)

  const result = []
  let blue = 1
  arrRedResult.forEach(line => {
    result.push(line.join('') + (blue++).toString().padStart(2, '0'))
    if (blue > 16) {
      blue = 1
    }
  })

  return result
}
```

我们将获取的彩票内容放在文件中以便于下一步操作：

```javascript
const firstPrize = getDoubleColorBall(1000).join('')
fs.writeFileSync('./hello.txt', firstPrize)
```

这样子，我们就得到了第一版的文件，这是其文件大小：

![](http://rq07mqsm6.hn-bkt.clouddn.com/u-image-bed/1678722223680.png)

试一下我们初步的压缩算法，我们将刚刚设定好的规则，也就是数字到字母的替换，用 JavaScript 实现出来，如下：





## 随机来两注

## 特意挑的两注

## 我要一等奖

## 黄粱一梦

## 结语
